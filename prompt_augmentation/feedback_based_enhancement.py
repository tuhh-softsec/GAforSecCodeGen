import google.generativeai as genai
from typing import List
from .abs_prompt_augmentation import AbstractPromptAugmentation
import os
from dotenv import load_dotenv
import json
import random
from config import config
import re


class FeedbackBasedEnhancement(AbstractPromptAugmentation):
    def __init__(self):
        super().__init__()
        load_dotenv()
        genai.configure(api_key=os.getenv('GEMINI_API_Key'))
        self.model = genai.GenerativeModel('gemini-pro')

    def extract_bandit_warnings(self, filepath: str) -> List[str]:
        with open(filepath, 'r') as file:
            data = json.load(file)
        warnings_per_file = []
        # extract the issue_text from the results as the warnings
        if data['results']:
            for result in data['results']:
                warnings_per_file.append(result['issue_text'])
        return warnings_per_file

    def select_n_warnings(self, warnings: List[str], num_warnings: int) -> List[str]:
        # remove duplicate warnings
        warnings = list(set(warnings))
        if len(warnings) < num_warnings:
            return warnings
        
        return random.sample(warnings, num_warnings)

    def augment_prompt(self, prompt: str, iteration: int, num_variations: int = 4) -> List[str]:
        all_warnings = []
        # read bandit results in the directory that starts with the iteration number
        for file in os.listdir(config.bandit_output_dir):
            if file.startswith(str(iteration)):
                warnings_per_file = self.extract_bandit_warnings(
                    f"{config.bandit_output_dir}/{file}")
                all_warnings.extend(warnings_per_file)
        
        
        if all_warnings:
            selected_warnings = self.select_n_warnings(
                all_warnings, 5)
        else:
            selected_warnings = []
        prompt_variations = []
        if selected_warnings:
            instruction = (f"Rewrite the CODE_GENERATION_PROMPT by incorporating the "
                           f"SECURITY_WARNINGS generated by a SAST tool while evaluating "
                           f"the code generated for different coding tasks.\n"
                           f"CODE_GENERATION_PROMPT: {prompt}\n"
                           f"SECURITY_WARNINGS: {selected_warnings}\n"
                           f"Note 1: Do not write any code, only write the modified prompt."
                           f"Note 2: The modified prompt should be concise and under 300 tokens."
                           )

            post_prompt = "Modified CODE_GENERATION_PROMPT: "

            input_text = f"{instruction} \n{post_prompt} "

            print("\nInput text sent to model:")
            print(input_text)
            print("\n" + "="*50 + "\n")

            # Generate variations sequentially instead of all at once
            for _ in range(num_variations):
                response = self.model.generate_content(
                    input_text,
                    generation_config={
                        'temperature': 0.7,
                    },
                    safety_settings={
                        "HARM_CATEGORY_DANGEROUS_CONTENT": "BLOCK_NONE",
                        "HARM_CATEGORY_HATE_SPEECH": "BLOCK_NONE",
                        "HARM_CATEGORY_HARASSMENT": "BLOCK_NONE",
                        "HARM_CATEGORY_SEXUALLY_EXPLICIT": "BLOCK_NONE"
                    }
                )
                prompt_variations.append(response.text)
            # Enhanced code detection checks
            filtered_variations = []
            for variation in prompt_variations:
                # Skip if any of these conditions are true
                if any([
                    # Check for code blocks with any language
                    re.search(r'```[\w\s]*\n', variation),
                    # Check for common programming keywords
                    # re.search(r'\b(def|class|import)\b', variation),
                    re.search(r'print\(.*\)', variation),   # Print statements
                    # Check for variable assignments
                    # re.search(r'\b\w+\s*=\s*[\w\'"]+', variation),
                    # Check for function calls
                    # re.search(r'\b\w+\(.*\)', variation),
                    # Check for indentation patterns
                    re.search(r'^\s{2,}', variation, re.MULTILINE)
                ]):
                    continue

                filtered_variations.append(variation)

            return filtered_variations if filtered_variations else [prompt]
            # return prompt_variations
        else:
            return [prompt]



def main():
    augmenter = FeedbackBasedEnhancement()

    test_prompt = """Generate secure python code for the given task description: """

    variations = augmenter.augment_prompt(test_prompt, 1)

    print("Raw model outputs:")
    print("=" * 50)
    for i, variation in enumerate(variations, 1):
        print(f"\nOutput {i}:")
        print("-" * 30)
        print(variation)
        print("-" * 30)


if __name__ == "__main__":
    main()
